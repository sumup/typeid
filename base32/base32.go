package base32

// Encoding and Decoding code based on the go implementation of ulid
// found at: https://github.com/oklog/ulid
// (Copyright 2016 The Oklog Authors)
// Modifications made available under the same license as the original

import (
	"errors"
)

var (
	// ErrInvalidLength is returned by Decode functions, if the input string is not 26-characters long.
	ErrInvalidLength = errors.New("invalid length")
	// ErrInvalidChar is returned by Decode functions, if a character in the input string is not a
	// valid base32 character for the respective encoding.
	ErrInvalidChar = errors.New("invalid base32 character")
)

const (
	// alphUp is the uppercase base32 alphabet.
	alphUp = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
	// alphUp is the lowercase base32 alphabet.
	alphLow = "0123456789abcdefghjkmnpqrstvwxyz"
)

// EncodeUpper encodes the src [16]byte into a base32 string with uppercase letters.
func EncodeUpper(src [16]byte) string {
	return Encode(src, alphUp)
}

// EncodeLower encodes the src [16]byte into a base32 string with lowercase letters.
func EncodeLower(src [16]byte) string {
	return Encode(src, alphLow)
}

// EncodeLowerTo encodes the src [16]byte into a provided 26-byte buffer using uppercase letters.
func EncodeUpperTo(dst []byte, src [16]byte) {
	EncodeTo(dst, src, alphUp)
}

// EncodeLowerTo encodes the src [16]byte into a provided 26-byte buffer using lowercase letters.
func EncodeLowerTo(dst []byte, src [16]byte) {
	EncodeTo(dst, src, alphLow)
}

func EncodeTo(dst []byte, src [16]byte, alphabet string) {
	// Optimized unrolled loop ahead.

	// 10 byte timestamp
	dst[0] = alphabet[(src[0]&224)>>5]
	dst[1] = alphabet[src[0]&31]
	dst[2] = alphabet[(src[1]&248)>>3]
	dst[3] = alphabet[((src[1]&7)<<2)|((src[2]&192)>>6)]
	dst[4] = alphabet[(src[2]&62)>>1]
	dst[5] = alphabet[((src[2]&1)<<4)|((src[3]&240)>>4)]
	dst[6] = alphabet[((src[3]&15)<<1)|((src[4]&128)>>7)]
	dst[7] = alphabet[(src[4]&124)>>2]
	dst[8] = alphabet[((src[4]&3)<<3)|((src[5]&224)>>5)]
	dst[9] = alphabet[src[5]&31]

	// 16 bytes of entropy
	dst[10] = alphabet[(src[6]&248)>>3]
	dst[11] = alphabet[((src[6]&7)<<2)|((src[7]&192)>>6)]
	dst[12] = alphabet[(src[7]&62)>>1]
	dst[13] = alphabet[((src[7]&1)<<4)|((src[8]&240)>>4)]
	dst[14] = alphabet[((src[8]&15)<<1)|((src[9]&128)>>7)]
	dst[15] = alphabet[(src[9]&124)>>2]
	dst[16] = alphabet[((src[9]&3)<<3)|((src[10]&224)>>5)]
	dst[17] = alphabet[src[10]&31]
	dst[18] = alphabet[(src[11]&248)>>3]
	dst[19] = alphabet[((src[11]&7)<<2)|((src[12]&192)>>6)]
	dst[20] = alphabet[(src[12]&62)>>1]
	dst[21] = alphabet[((src[12]&1)<<4)|((src[13]&240)>>4)]
	dst[22] = alphabet[((src[13]&15)<<1)|((src[14]&128)>>7)]
	dst[23] = alphabet[(src[14]&124)>>2]
	dst[24] = alphabet[((src[14]&3)<<3)|((src[15]&224)>>5)]
	dst[25] = alphabet[src[15]&31]
}

// Encode encodes the src [16]byte into a base32 string with the given alphabet.
// The alphabet must be 32 bytes long. If the alphabet is shorter, the function
// will panic. It's the callers responsiblity to ensure the alphabet is valid.
//
// Direct usage is discouraged. Use EncodeUpper or EncodeLower instead.
func Encode(src [16]byte, alphabet string) string {
	dst := make([]byte, 26)
	EncodeTo(dst, src, alphabet)
	return string(dst)
}

// We us byte index tables for O(1) lookups when unmarshaling.
// We use 0xFF as sentinel value for invalid indexes.
var (
	// decUpper is the uppercase letter index table for decoding.
	decUpper = [256]byte{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
		0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
		0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14, 0x15, 0xFF,
		0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	}
	// decLower is the lowercase letter index table for decoding.
	decLower = [256]byte{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
		0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,
		0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,
		0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,
		0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	}
)

// DecodeUpper decodes a uppercase base32 string into a 16-byte slice.
func DecodeUpper(s string) ([]byte, error) {
	return Decode(s, decUpper)
}

// DecodeLower decodes a lowercase base32 string into a 16-byte slice.
func DecodeLower(s string) ([]byte, error) {
	return Decode(s, decLower)
}

// Decode decodes a given base32 string into a 16-byte slice. The second argument is a index lookup table, that
// must be 256 bytes long. If the table is shorter, the function will panic. It's the callers responsiblity to
// ensure the table is valid.
//
// Direct usage is discouraged. Use DecodeUpper or DecodeLower instead.
func Decode(s string, idxTable [256]byte) ([]byte, error) {
	if len(s) != 26 {
		return nil, ErrInvalidLength
	}

	val := []byte(s)
	// Check if all the characters are part of the expected base32 character set.
	if idxTable[val[0]] == 0xFF ||
		idxTable[val[1]] == 0xFF ||
		idxTable[val[2]] == 0xFF ||
		idxTable[val[3]] == 0xFF ||
		idxTable[val[4]] == 0xFF ||
		idxTable[val[5]] == 0xFF ||
		idxTable[val[6]] == 0xFF ||
		idxTable[val[7]] == 0xFF ||
		idxTable[val[8]] == 0xFF ||
		idxTable[val[9]] == 0xFF ||
		idxTable[val[10]] == 0xFF ||
		idxTable[val[11]] == 0xFF ||
		idxTable[val[12]] == 0xFF ||
		idxTable[val[13]] == 0xFF ||
		idxTable[val[14]] == 0xFF ||
		idxTable[val[15]] == 0xFF ||
		idxTable[val[16]] == 0xFF ||
		idxTable[val[17]] == 0xFF ||
		idxTable[val[18]] == 0xFF ||
		idxTable[val[19]] == 0xFF ||
		idxTable[val[20]] == 0xFF ||
		idxTable[val[21]] == 0xFF ||
		idxTable[val[22]] == 0xFF ||
		idxTable[val[23]] == 0xFF ||
		idxTable[val[24]] == 0xFF ||
		idxTable[val[25]] == 0xFF {
		return nil, ErrInvalidChar
	}

	res := make([]byte, 16)

	res[0] = (idxTable[val[0]] << 5) | idxTable[val[1]]
	res[1] = (idxTable[val[2]] << 3) | (idxTable[val[3]] >> 2)
	res[2] = (idxTable[val[3]] << 6) | (idxTable[val[4]] << 1) | (idxTable[val[5]] >> 4)
	res[3] = (idxTable[val[5]] << 4) | (idxTable[val[6]] >> 1)
	res[4] = (idxTable[val[6]] << 7) | (idxTable[val[7]] << 2) | (idxTable[val[8]] >> 3)
	res[5] = (idxTable[val[8]] << 5) | idxTable[val[9]]
	res[6] = (idxTable[val[10]] << 3) | (idxTable[val[11]] >> 2)
	res[7] = (idxTable[val[11]] << 6) | (idxTable[val[12]] << 1) | (idxTable[val[13]] >> 4)
	res[8] = (idxTable[val[13]] << 4) | (idxTable[val[14]] >> 1)
	res[9] = (idxTable[val[14]] << 7) | (idxTable[val[15]] << 2) | (idxTable[val[16]] >> 3)
	res[10] = (idxTable[val[16]] << 5) | idxTable[val[17]]
	res[11] = (idxTable[val[18]] << 3) | idxTable[val[19]]>>2
	res[12] = (idxTable[val[19]] << 6) | (idxTable[val[20]] << 1) | (idxTable[val[21]] >> 4)
	res[13] = (idxTable[val[21]] << 4) | (idxTable[val[22]] >> 1)
	res[14] = (idxTable[val[22]] << 7) | (idxTable[val[23]] << 2) | (idxTable[val[24]] >> 3)
	res[15] = (idxTable[val[24]] << 5) | idxTable[val[25]]

	return res, nil
}
